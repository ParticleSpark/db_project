 
 
高级数据库课程报告
 

项目选题：蔬菜类商品的销售数据库实现
姓    名： 
学    号： 
院    系：计算机科学与技术学院
专    业：计算机科学与技术
完成日期：2024 年 12 月 25 日

          
  
目录
摘要	II
小组分工	III
第一章	研究背景和意义	1
1.1 研究背景	1
1.2 数据集介绍	1
1.3 研究意义	2
第二章	研究目标和内容	3
2.1 研究内容	3
2.2 研究目标	4
第三章	数据库存储设计	5
3.1 原始数据分析	5
3.2 关系型数据库存储设计	7
3.3 时序数据库存储设计	13
第四章	关系型数据库的查询与优化	19
4.1 查询设计	19
4.2 关系型数据库的优化：索引	28
4.2 对比：Postgres与DuckDB	29
第五章	时序数据库的查询	31
5.1 简单查询	31
5.2 复杂查询	33
第六章	关系型数据库与时序数据库的性能对比	36
6.1 简单查询	36
6.2 复杂查询	38
第七章	实例展示	39
7.1 功能详解	39
7.2 技术实现	41
7.3 界面展示	49
第八章	总结和不足	52
参考文献	53

 
摘要
本项目通过生鲜商超蔬菜商品数据集，比较了关系型数据库（Postgres、DuckDB）与时序数据库（InfluxDB）在处理复杂数据结构和大规模时间序列数据时的性能差异。实验从商品销量分析、进货/销售数据更新、季节性销售分析等三大应用目标出发，评估了各数据库在查询效率、执行性能和响应速度上的表现。实验结果表明，在读取查询中，DuckDB的性能普遍优于Postgres，而Postgres通过创建索引显著加速了简单查询的执行，尤其在复杂查询中表现较好。相比之下，InfluxDB在某些查询下表现较差，主要由于其数据返回时间较长，尤其是在非时序数据查询时不如关系型数据库高效。尽管InfluxDB在时序数据写入和分析上有优势，但在复杂查询和多表关联时，关系型数据库的性能更为突出。此外，本研究还探讨了SQL与InfluxQL在查询语句支持上的差异，为开发者在不同业务场景中选择适合的数据库提供了有价值的参考。针对该实践，基于DuckDB的轻量级数据库操作系统VegSalesDB已发布并部署到GitHub前端界面，可以通过https://jeekzhang.github.io/VegSalesDB进行访问和体验。

关键词：高级数据库，销售数据分析，数据库性能对比，数据库优化，大规模数据处理

 
小组分工
林琰钧
1.	制定本小组的研究题目，包括数据集与数据库的选择
2.	进行任务分工，并参与组织小组的线下讨论
3.	负责数据库的存储设计工作，包括关系数据库的关系表设计，以及时序数据库的数据点设计
4.	完成所负责部分的开题与中期的PPT制作、结题的Poster制作、论文的撰写工作
5.	在中期阶段上台展示PPT，并进行讲解汇报
叶兴松
1.	积极参与线下小组讨论，与团队成员共同修订和完善PPT和Poster，确保项目展示材料的质量和效果
2.	负责制作Demo展示界面，构建演示用的VegSalesDB，具体内容可详见报告第七章
3.	完成所负责部分的开题与中期的PPT制作、结题的Poster制作，以及代码和论文的撰写工作，确保研究成果的系统性和专业性
4.	在开题阶段被选中上台展示，进行详细的讲解和汇报，使项目内容得到有效清晰的传达
5.	负责整合所有人的论文材料，统一格式，完善补充（包括摘要、第一二章的内容）形成结题论文
李小雨
柯舒林
胡鑫
1. 参加线下讨论，完成负责部分的PPT和Poster
2. 负责时序数据库Influxdb部署，初步探索，以及把关系型数据库中的数据按照时序数据的规范要求插入时序数据库
3. 帮助关系型数据库与时序数据库进行同台服务器部署，性能对比
刘宇轩
贺禄元
 
第一章	研究背景和意义
1.1 研究背景
随着现代零售行业的快速发展，生鲜商超的销售数据呈现爆发式增长，尤其是蔬菜类商品的销售数据，其涉及多品类、长时间跨度和大数据量，构成了数据管理和分析的重要课题。如何高效地存储、管理、分析这些数据，不仅直接影响企业的经营决策效率，还对供应链优化、库存管理和销售策略的制定具有重要意义。
目前，主流数据库分为关系型数据库和非关系型数据库两大类，二者在数据结构、存储方式和查询效率等方面各有特色。关系型数据库以其结构化的表设计和强大的事务处理能力广泛应用于商业领域，但在处理大规模时间序列数据和高频更新时，可能面临性能瓶颈。与之相比，时序数据库专为高频数据插入和时间维度分析而设计，能够在时间序列查询场景中展现显著优势。因此，在多样化的生鲜商超场景中，结合两类数据库的特点对其进行对比分析显得尤为重要。
1.2 数据集介绍
本项目使用的生鲜商超蔬菜类商品销售数据集，涵盖六个主要品类，时间跨度为三年，总数据量庞大，呈现出显著的多样性与复杂性。数据集采用多表结构，包括商品信息表、销售流水表、库存记录表及门店信息表等，各表通过外键字段紧密关联，具有强结构化特征。核心数据表销售流水表包含精确到秒的时间戳，适用于时间序列分析，支持多维度、多角度的数据探索需求。该数据集不仅能够揭示商品销量趋势、季节性规律，还可以通过实时分析实现库存优化和促销策略调整，是数据库设计与性能评估的理想测试场景。
1.3 研究意义
本研究通过对蔬菜类商品的销售数据进行存储与分析，探索关系型数据库（如PostgreSQL [1]和DuckDB [2]）与时序数据库（如InfluxDB [3]）在实际应用中的表现。通过实验研究，不仅可以揭示两种数据库在处理不同类型查询、数据量规模变化和实时更新操作中的优劣，还为实际生产环境中的数据库选择提供了科学依据。
具体而言，以下几点是本研究的主要意义：
（1）为商超企业提供数据管理方案：通过分析不同数据库在销售数据管理中的性能表现，帮助企业优化数据库架构设计，提高数据分析效率。
（2）推动数据库技术的优化与应用：通过性能测试与优化策略研究，为数据库开发者提供改进建议，提升数据库系统的可靠性和高效性。
（3）拓展时序数据库的应用场景：研究时序数据库在非传统应用场景（如零售数据分析）中的适用性，为其在零售领域的推广提供参考。





第二章	 研究目标和内容
2.1 研究内容
本研究以生鲜商超蔬菜类商品的销售数据为研究对象，设计了一套完整的实验方案，围绕关系型数据库与时序数据库的性能表现展开对比分析。研究内容主要包括以下几个方面：
（1）数据库设计与建模
针对销售数据的特点，分别设计适合关系型数据库和时序数据库的数据模型。在关系型数据库中，采用多表设计，表间通过外键建立关联；在时序数据库中，采用单表设计，数据通过标签和时间戳索引进行分类和检索。具体来说，“商品销售流水表”在PostgreSQL中可能包括多个字段如商品编码、销售时间、销售数量和销售额，通过外键与“商品信息表”关联。而在InfluxDB中，同样的数据会存储为一个时间序列，带有标签字段如商品编码和门店编号，时间戳则作为主索引。
（2）查询类型的对比
分析两类数据库在常见查询任务中的表现，主要包括：
	销量分析：统计某段时间内不同品类蔬菜的销售额和销售量；
	季节性趋势分析：通过时间序列分析，挖掘商品的季节性销售规律；
	数据更新操作：测试不同数据库在商品信息更新或库存调整操作中的响应效率。例如，使用SQL [4]中的JOIN操作将PostgreSQL中的多个表联接，统计各商品的销量；而在InfluxDB中，则通过InfluxQL直接对时间序列数据进行聚合统计。
（3）性能评估实验
在不同数据规模和查询复杂度下，比较关系型数据库与时序数据库的查询能力和执行性能。具体实验包括：
	大规模数据查询：在销售流水达到千万级别时，测试复杂查询的响应速度。
	实时更新性能：模拟实际业务场景中高频数据写入和更新的压力测试。
	索引优化效果：评估关系型数据库索引优化（如B树索引和哈希索引）与时序数据库标签索引在查询性能上的提升幅度。
（4）优化策略研究
针对两类数据库的特点，研究如何通过优化查询语句、调整存储策略等手段提升查询效率。例如：
	在关系型数据库中，研究创建联合索引和分区表的效果；
	在时序数据库中，探索合适的时间范围分段策略和标签设计方案。
2.2 研究目标
本研究旨在通过理论分析和实验验证，全面评估关系型数据库和时序数据库在生鲜商超蔬菜类商品销售数据管理中的适用性，明确两种数据库在不同查询任务和数据规模下的性能表现，为实际业务场景中的数据库选择提供参考；同时，针对实验中发现的性能瓶颈，研究优化数据库设计与查询方式的策略，以提升查询效率和数据处理能力；此外，还将探讨时序数据库在销售分析和时序预测场景中的应用潜力，为其在零售及其他行业的推广提供理论支持和实践依据。
第三章	数据库存储设计
本章描述我们是如何从若干个以Excel文件形式呈现的原始数据中进行关系型数据库（DuckDB和Postgres）和时序数据库（InfluxDB）的存储设计。
3.1 原始数据分析
原始数据来自多个Excel表格，包括附件1到附件4，且每个Excel表中可能包含多个子表。表3-1到表3-5显示了原始数据的各表格前5行的内容。
表3-1 附件1.xlsx - Sheet1 前5行预览
单品编码	单品名称	分类编码	分类名称
102900005115168	牛首生菜	1011010101	花叶类
102900005115199	四川红香椿	1011010101	花叶类
102900005115625	本地小毛白菜	1011010101	花叶类
102900005115748	白菜苔	1011010101	花叶类
102900005115762	苋菜	1011010101	花叶类
表3-2 附件2.xlsx - Sheet1 前5行预览
销售日期	扫码销售时间	单品编码	销量(千克)	销售单价(元/千克)	销售类型	是否打折销售
2020-07-01	09:15:07.924	102900005117056	0.396	7.6	销售	否
2020-07-01	09:17:27.295	102900005115960	0.849	3.2	销售	否
2020-07-01	09:17:33.905	102900005117056	0.409	7.6	销售	否
2020-07-01	09:19:45.450	102900005115823	0.421	10.0	销售	否
2020-07-01	09:20:23.686	102900005115908	0.539	8.0	销售	否
表3-3 附件3.xlsx - Sheet1 前5行预览
日期	单品编码	批发价格(元/千克)
2020-07-01	102900005115762	3.88
2020-07-01	102900005115779	6.72
2020-07-01	102900005115786	3.19
2020-07-01	102900005115793	9.24
2020-07-01	102900005115823	7.03
表3-4 附件4.xlsx - 平均损耗率(%)_小分类编码_不同值 前5行预览
小分类编码	小分类名称	平均损耗率(%)
1011010201	花菜类	15.51
1011010402	水生根茎类	13.65
1011010101	花叶类	12.83
1011010801	食用菌	9.45
1011010504	辣椒类	9.24
表3-5 附件4.xlsx - Sheet1 前5行预览
单品编码	单品名称	损耗率(%)
102900005115168	牛首生菜	4.39
102900005115199	四川红香椿	10.46
102900005115250	西峡花菇(1)	10.80
102900005115625	本地小毛白菜	0.18
102900005115748	白菜苔	8.78
原始数据的问题主要包括：
1、字段命名混乱且无统一规则，且字段类型不明晰；
2、某些数据表缺乏主键，不能唯一标识一条记录；
3、存在重复数据与冗余字段；
为了解决这些问题，需要对表格进行系统化设计，转化为符合数据库存储要求的结构。
3.2 关系型数据库存储设计
对于关系型数据库而言，关系表的设计思路如下：首先，通过分析表格结构和数据内容，制定了一系列的表格字段命名规则和数据类型规范；随后，识别或添加各表的主键，并基于主键与外键设计了表间的关系；最后，利用第三范式（3NF） [5]对表格数据进行规范化处理，形成了最终的数据库关系模式和ER图 [6]。
3.2.1 命名与类型规范化
原始数据中各附件字段名称大多以中文表示，存在冗余与重复现象，直接导入关系型数据库可能导致命名冲突或语义模糊。因此，需要制定统一的字段命名与类型规则，确保字段名称具有语义清晰、简洁易读的特点。我们统一使用英文命名，将中文字段名翻译为对应的英文名，并使用下划线命名法（snake_case），保证字段名统一风格。此外，我们根据原始数据中每列的值域范围及用途，分配合理的数据类型，以优化数据库存储性能和查询效率。
所有关系表的命名规范化如表3-6所示，所有出现的字段的命名与类型规范化如表3-7所示。
表3-6 关系表的命名规范化
关系表名称	原始数据表名称	说明
category	附件4.xlsx - 平均损耗率(%)_小分类编码_不同值	品类表
product	附件1.xlsx - Sheet1，附件4.xlsx - Sheet1	单品表
sale	附件2.xlsx - Sheet1	销售表
wholesale	附件3.xlsx - Sheet1	批发表
表3-7 字段的命名与类型规范化
字段名称	数据类型	说明
category_id	VARCHAR	分类编号
category_name	VARCHAR	分类名称
average_loss_rate	DECIMAL(5, 2)	小分类的平均损耗率
product_id	VARCHAR	商品的唯一编码
product_name	VARCHAR	商品名称
loss_rate	DECIMAL(5, 2)	单品的损耗率
sale_date	DATE	销售日期
sale_time	TIME	销售时间
sale_quantity	DECIMAL(10, 2)	销量（千克）
sale_price	DECIMAL(10, 2)	销售单价（元/千克）
discounted	BOOLEAN	是否打折销售
wholesale_date	DATE	批发日期
wholesale_price	DECIMAL(10, 2)	批发价格（元/千克）
3.2.2 主键与外键关系设计
为了实现数据库中表与表之间的逻辑关联，同时保证数据的完整性和唯一性，需要合理设计主键和外键。以下基于附件提供的原始数据，详细说明各表主键和外键的设计。
1. 主键（Primary Key）设计
主键是关系表中用于唯一标识记录的字段，确保数据不重复。以下为各表的主键设计：
1、category表（品类表）：category_id（分类编号），唯一标识每个分类。
2、product表（单品表）：product_id（商品编码），唯一标识每种商品。
3、sale表（销售表）：本身没有主键，新增一个从1开始递增的字段sale_id（销售流水号），唯一标识每条销售记录。
4、wholesale表（批发表）：本身没有主键，新增一个从1开始递增的字段wholesale_id（新增字段），唯一标识每条批发记录。
2. 外键（Foreign Key）设计
外键用于建立表与表之间的关系，以下为外键设计：
1、product表（单品表）中的外键：category_id（分类编号），关联category表的category_id，表示商品所属分类。
2、sale表（销售表）中的外键：product_id（商品编码），关联product表的product_id，表示销售记录对应的商品。
3、wholesale表（批发表）中的外键：product_id（商品编码），关联product表的product_id，表示批发记录对应的商品。
3.2.3 第三范式规范化处理
为了消除数据冗余与更新异常，同时优化数据库存储结构，需要对原始数据进行范式化处理，目标是将其转换为符合第三范式（3NF）的结构。
1. 范式化前的问题
1、字段冗余：
（1）在附件1中，分类名称字段重复出现在多条记录中，与分类编码字段存在依赖关系。
（2）在附件4中，小分类平均损耗率与单品损耗率数据混杂。
2、缺少主键：
原始表格中缺乏唯一标识一条记录的主键字段，例如附件2的销售流水记录无主键。
2. 规范化处理步骤
根据第三范式的定义，需确保每个非主属性完全依赖于主键，同时消除传递依赖。由于缺少主键的问题已在3.2.2节中解决，以下处理字段冗余的问题：
1、拆分商品与分类数据：
（1）将附件1中的单品编码、单品名称与分类编码拆分为product表；
（2）将分类编码和分类名称提取为独立的category表，消除冗余。
2、合并存储损耗率信息：
（1）附件4中的商品损耗率存储为product表的属性loss_rate；
（2）小分类平均损耗率存储为category表的属性average_loss_rate。
3.2.4 最终关系型数据库设计
基于上述分析，最终设计出4 张关系表，它们的ER图如图3-1所示。该ER图展示了一个完整的关系型数据库设计方案，包含了四个核心实体：品类表（category）、商品表（product）、销售表（sale）和批发表（wholesale）。通过主键（Primary Key，PK）与外键（Foreign Key，FK）的设计，这些实体之间形成了紧密的逻辑关系（||--o{ 表示 一对多关系），确保了数据的规范性、一致性和可扩展性。
 
图3-1 ER图
1. 品类表（category）
品类表是数据库的基础实体之一，用于存储商品的分类信息。表中包含三个主要字段：category_id（分类编号）、category_name（分类名称）和average_loss_rate（平均损耗率）。category_id是品类表的主键，用于唯一标识每个分类，例如“花叶类”或“花菜类”。每个分类记录存储了该分类的名称以及平均损耗率，以便对该分类的整体表现进行统计分析。
品类表与商品表（product）之间通过category_id建立了一对多的关系。即，一个分类可以包含多个商品，而每个商品只能属于一个分类。这种设计确保了分类信息的集中存储，避免了商品表中重复存储分类数据的问题。
2. 商品表（product）
商品表存储了商品的基础信息，是数据库中的核心实体之一。表中包含四个主要字段：product_id（商品编号）、product_name（商品名称）、category_id（分类编号，外键）和loss_rate（损耗率）。其中，product_id是商品表的主键，用于唯一标识每种商品，例如“牛首生菜”或“本地小毛白菜”。
商品表通过category_id字段与品类表建立关联，表示每种商品所属的分类。此外，表中还包含了具体商品的损耗率字段loss_rate，用来表示某种商品在储存或销售过程中的具体损耗百分比。这一字段可用于细粒度分析商品的保存性能或运营成本。
3. 销售表（sale）
销售表用于记录商品的销售信息，是动态数据的重要来源。表中包含以下主要字段：sale_id（销售流水编号，主键）、sale_date（销售日期）、sale_time（销售时间）、product_id（商品编号，外键）、sale_quantity（销量，单位为千克）、sale_price（销售单价，单位为元/千克）、sale_type（销售类型）和discounted（是否为打折销售）。
销售表中的主键是sale_id，确保每条销售记录的唯一性。product_id是外键，用于关联商品表（product），表示某条销售记录对应的具体商品。通过这种关联，可以查询某商品的销售详情、销售价格、销量以及是否打折等信息。
销售表的设计重点在于动态记录商品的销售过程，允许按照日期、时间、商品等维度进行详细的销售数据分析。例如，可以查询某个时间段内某类商品的销售额，分析销售趋势或折扣销售对总体销售额的影响。
4. 批发表（wholesale）
批发表用于记录商品的批发信息，是与销售表并列的另一类动态数据。批发表包含以下主要字段：wholesale_id（批发记录编号，主键）、wholesale_date（批发日期）、product_id（商品编号，外键）和wholesale_price（批发价格，单位为元/千克）。
批发表中的主键是wholesale_id，保证每条批发记录的唯一性。product_id字段作为外键关联商品表（product），表示某条批发记录所对应的具体商品。批发价格字段（wholesale_price）记录了商品在某一日期的批发单价，便于追踪价格波动。
通过批发表，可以分析商品的批发价格趋势，与销售价格进行对比，从而了解商品的利润空间或市场变化情况。
3.3 时序数据库存储设计
时序数据库InfluxDB专为时间序列数据优化设计，由于其设计特点（如数据点结构存储、缺乏JOIN操作支持），需要在数据写入之前对数据进行适当的结构变换和预处理。本节通过对关系型数据库中category、product、sale和wholesale等关系表的分析，将多表合并为宽表（Wide Table），并设计了适合时序数据库的存储方案，以实现高效的数据写入和查询。
3.3.1 存储结构与设计挑战
不同于关系型数据库中的行和表结构，时序数据库的数据存储单位为Point，每个数据点由以下核心部分组成：
1、测量名称（measurement）：类似于关系型数据库中的表名，用于区分数据点的逻辑归属。
2、标签（tag）：离散的键值对，用于对数据点进行分类或索引操作，常用于快速筛选。
3、字段（field）：具体的数据值，包括连续值（如销量、价格）或离散值（如布尔值、字符串等），是查询分析的主要内容。
4、时间戳（time）：每个Point都与一个时间戳绑定，表示数据记录的发生时间，支持纳秒级的高精度时间。
这种存储设计使得时序数据库能够快速查询时间范围内的某一类别数据，但由于其去关系化设计，不支持类似关系型数据库的JOIN操作。因此，任何涉及多表的复杂查询需求都必须在写入时完成数据的预处理和整合。具体而言，时序数据库的数据存储设计需要解决以下问题：
1、宽表设计：需要将product和category表的信息预先合并到sale和wholesale表中，形成单一宽表结构，避免查询时的关联问题。
2、字段划分：如何合理地将字段划分为标签（tag）、数据（field）和时间（time），以最大化利用InfluxDB的索引优势和查询性能。
3.3.2 宽表设计与字段划分
我们针对上述时序数据库的数据存储设计问题，进行以下的设计：
1、宽表设计：通过预先的JOIN操作，将相关联的数据表合并为宽表。具体而言，将product和category表中的内容分别合并到sale和wholesale表中，形成sale和wholesale两张宽表，即时序数据库中的两个测量名称（measurement）。
2、字段划分：将关系表的主键（包括sale_id、wholesale_id、product_id和category_id）设置为标签（tags），以支持快速筛选和高效索引。将剩余的非时序数据（如sale_quantity、sale_price、product_name和category_name等）设置为字段（fields）。对于sale宽表，将时间相关字段（sale_date和sale_time）整合为高精度的时间戳(纳秒级)；对于wholesale宽表，直接将时间相关字段（wholesale_date）设置为高精度的时间戳(纳秒级)。
3.2.3 最终时序数据库设计
基于上述分析，为适配时序数据库的特性，sale（销售）和wholesale（批发）两个测量（Measurement）的数据点（Point）设计如图3-2所示。设计以数据点为核心单元，结合时序数据库的数据存储规范，明确了标签（tag）、字段（field）和时间戳（time）的划分，确保了高效的数据存储与检索能力。
 
图3-2 时序数据库的数据点设计
1. 销售数据点（sale）
销售数据点（sale）用于记录商品的销售信息，是时序数据库中动态数据的重要来源。每个数据点代表一条具体的销售记录，包含以下核心信息：销售流水编号（sale_id）、销售时间戳（time）、商品编号（product_id）、分类编号（category_id）、商品名称（product_name）、分类名称（category_name）、销售数量（sale_quantity）、销售单价（sale_price）、销售类型（sale_type）、商品损耗率（loss_rate）、分类平均损耗率（average_loss_rate）以及是否为折扣销售（discounted）。
销售数据点的时间戳（time）记录了每条销售数据的具体发生时间，由销售日期（sale_date）和销售时间（sale_time）组合而成，支持纳秒级精度，确保高频数据存储的准确性。sale_id是数据点中的标签字段之一，用于唯一标识每条销售记录。标签还包括product_id和category_id，分别表示该记录关联的商品和分类，这些标签字段的设计便于对销售数据进行快速筛选和分组，例如按商品、分类或流水号快速检索数据。
字段（field）部分存储了与销售记录相关的动态和静态信息。例如，sale_quantity和sale_price字段记录了商品的销售量和单价，是计算销售额的关键数据；sale_type字段表示销售渠道（如零售、线上）；而discounted字段用于区分是否属于折扣销售。此外，product_name和category_name字段提供商品和分类的名称信息，便于查询结果的语义化；loss_rate和average_loss_rate字段则用于描述商品和分类的损耗率，支持进一步的运营效率分析。
销售数据点的设计重点在于动态记录商品的销售过程，允许按时间范围、商品编号或分类编号进行高效查询和分析。例如，可以查询某一时间段内某商品的总销售额，分析销售趋势，或评估折扣销售对总体收入的影响。这一设计充分利用了时序数据库高效处理动态数据的优势，满足了复杂的商品销售分析需求。
2. 批发数据点（wholesale）
批发数据点（wholesale）用于记录商品的批发信息，是时序数据库中另一类重要的动态数据来源。每个数据点代表一条批发记录，包含以下核心信息：批发记录编号（wholesale_id）、批发时间戳（time）、商品编号（product_id）、分类编号（category_id）、商品名称（product_name）、分类名称（category_name）、商品损耗率（loss_rate）、分类平均损耗率（average_loss_rate）以及批发价格（wholesale_price）。
批发数据点的时间戳（time）由批发日期（wholesale_date）字段直接生成，记录每条批发记录的发生时间。wholesale_id是数据点中的标签字段之一，用于唯一标识每条批发记录。与销售数据点类似，批发数据点还包含product_id和category_id作为标签字段，用于快速筛选与特定商品或分类相关的批发数据。
字段（field）部分存储了与批发记录相关的动态和静态信息。例如，wholesale_price字段记录商品的批发单价，是追踪价格波动的关键数据；product_name和category_name字段提供商品和分类的语义化信息，便于结果展示；loss_rate和average_loss_rate字段用于描述商品和分类的损耗率，支持对商品或分类在批发环节的表现分析。
批发数据点的设计重点在于记录商品的批发价格及相关信息，支持基于时间、商品编号或分类编号的高效查询和批发数据分析。例如，可以分析某一商品在不同时间的批发价格波动，与销售价格进行对比，评估利润空间；或者通过分类统计分析，了解某一分类商品的整体成本趋势和市场表现。这一设计充分适配了时序数据库的特性，为商品批发业务提供了高效的动态数据管理能力。 
第四章	关系型数据库的查询与优化
4.1 查询设计
4.1.1 时序数据库支持的简单查询设计
为了体现时序数据库的特性，我们设计了一些基于InfluxDB的简单查询，这些查询利用了InfluxDB独有的Flux语法 [7]，具体设计将在5.1节中说明。为了在时序数据库与两种关系型数据库上进行性能对比，分析不同数据库在性能上的异同，我们将这些查询转化成了等价的关系型数据库SQL。

4.1.2 基于性能的复杂查询设计
在本实验中，我们设计了五条复杂查询，借鉴了TPC-H [8]的查询特点，目的是模拟复杂场景中数据分析的需求。这些查询涵盖了多表联结、分组统计、嵌套子查询和复杂过滤条件等典型的 OLAP 工作负载，以测试数据库在大规模数据分析中的性能表现。
此外，复杂查询的设计旨在对比 OLTP 和 OLAP 的性能差异。与简单查询相比，复杂查询引入了更高的计算复杂度和更大的数据处理量，这不仅可以测试数据库优化器在生成查询计划时的效率，还可以观察查询性能在负载增加时的线性扩展性。通过这些复杂查询，可以深入分析数据库在资源利用、吞吐能力和查询响应时间上的表现，从而更全面地对比 OLTP 和 OLAP 工作负载的特性和差异。
（1）Q1查询
目标：带有分组、排序、聚集操作并存的单表查询操作，会导致表上的数据大多数行被读取到。
逻辑说明：
	从 sale 表中按 sale_type 进行分组。
	通过 SUM(sale_quantity) 计算每种销售类型的总销售数量。
	使用 AVG(sale_price) 计算每种销售类型的平均销售价格。
	通过 AVG(CASE WHEN discounted THEN 1 ELSE 0 END) 计算每种销售类型中应用折扣的平均比例。
（2）Q2查询
目标：带有分组、排序、聚集操作、子查询并存的多表连接查询操作。
逻辑说明：
	联结 category、product、sale 和 wholesale 表，按商品品类（category_id）分组。
	使用 SUM(st.sale_quantity * st.sale_price) 计算每个品类的总销售额。
	使用子查询筛选出批发价格（wholesale_price）高于平均批发价格的商品。
	在筛选的基础上，通过 WHERE st.sale_date BETWEEN '2020-07-01' AND '2020-12-31' 限定日期范围，分析高价值商品的销售表现。
	最终按总销售额降序排列，用于判断高利润品类的表现。
（3）Q3查询
目标：带有分组、排序、聚集、子查询操作并存的查询操作。子查询的父层查询不存在其他查询对象，是格式相对简单的子查询，但子查询自身是多表连接的查询，并且使用了LIKE操作符
逻辑说明：
	在子查询中，关联 product 和 sale 表，通过 vp.product_name LIKE '%(份)%' 筛选名称中包含“份”的商品。
	在子查询中按 product_id 分组，统计每种商品的总销售数量、平均价格和损耗率。
	在主查询中，基于子查询结果，按品类（category_id）分组，汇总总销售额（SUM(total_sale_quantity * average_price)）和平均损耗率（AVG(avg_loss_rate)）。
	最终结果按总销售额降序排列，显示损耗率较低且销售额较高的商品品类。
（4）Q4查询
目标：带有分组、排序、聚集、子查询、左外连接操作并存的查询操作
逻辑说明：
	使用子查询统计 sale 表中每种商品（product_id）的订单总数。
	通过外联结（LEFT OUTER JOIN），将产品表 product 和子查询结果关联，确保未出现在销售表中的商品仍保留。
	通过外联结（LEFT OUTER JOIN），将产品表 product 和子查询结果关联，确保未出现在销售表中的商品仍保留。
	按订单数量和无订单数量同时降序排列，分析哪些商品销售量大或完全未售出的情况。
（5）Q5查询
目标：带有排序、聚集、IN子查询、普通子查询操作并存的多表连接操作
逻辑说明：
	联结 category、product、sale 和 wholesale 表，按商品（product_name）和品类（category_name）分组。
	计算总销售数量（SUM(s.sale_quantity)）、总销售额（SUM(s.sale_quantity * s.sale_price)）、总利润（SUM(s.sale_quantity * (s.sale_price - w.wholesale_price))）和平均批发价格（AVG(w.wholesale_price)）。
	子查询筛选出销售总量超过 100 的商品，用于分析热销产品。
	使用 HAVING total_revenue > 5000 筛选出总销售额高于 5000 的商品，确保聚焦于关键产品。
	最终按总利润、总销售额和销售次数同时降序排列，分析高利润商品的表现。
4.1.3 基于实际场景的查询设计
为了满足蔬菜商品销售场景的实际需求，还设计了一套基于关系型数据库的查询方案，用以分析商品的销售与批发表现。
（1）Q6查询
目标：获取特定日期范围内每个商品品类的平均销售价格和平均批发价格，用于分析宏观价格趋势。
输入：时间范围（如 2020-07-01 至 2020-12-31）。
输出：返回每个品类的平均销售价格与平均批发价格。
逻辑说明：
	将 category、product、sale 和 wholesale 四张表关联。
	按 category_id 分组。
	使用 AVG(sale_price) 和 AVG(wholesale_price) 分别计算平均销售价和批发价。
	使用 WHERE 子句过滤特定日期范围内的数据。

（2）Q7查询
目标：获取每天不同品类的销售总量与平均批发价格，并对每个品类筛选销量排名前5的商品。
输入：时间范围（如 2020-07-01 至 2020-12-31）。
输出：返回每个品类销量排名前5的商品及其销售总量和批发价格。
逻辑说明：
	使用 WITH 子句和递归查询生成每个品类的销量排名。
	使用 ROW_NUMBER() 窗口函数按 category_id 分区，并按销量降序排列。
	在最终查询中筛选 rank <= 5 的商品。
 
（3）I1 插入语句
	目标：添加一条新的批发（进货）信息到 wholesale 表中。在进货时检查 product 表中是否存在对应的商品。如果 product 表中没有该商品，则将该商品插入到 product 表中。
	输入：商品信息、批发信息。
输出： 批发记录插入到 wholesale 表中，且商品信息在 product 表中已存在。
实现细节：
	商品表插入：利用 ON CONFLICT (product_id) DO NOTHING 避免重复插入相同的商品记录。保证新商品的唯一性，若商品已存在则跳过。
	批发表插入：将 wholesale_date、product_id 和 wholesale_price 添加到批发记录中。每次插入一批新的批发记录。
 
（4）D1 删除语句
	目标：删除某个分类及其关联商品和关联的批发、销售记录。
	输入： 分类 ID（category_id）。
输出： 删除指定分类 ID 所对应的分类记录、商品记录，以及相关的批发记录和销售记录。
实现：分步骤删除相关表中的记录，先删除从属数据（如销售和批发记录），最后删除分类。
 
（5）U1 修改语句
	目标：修改某个商品的损耗率，并重新计算所属分类的平均损耗率。
输入：商品 ID（product_id）、的损耗率值（loss_rate）。
输出：更新商品表（product）中指定商品的损耗率；更新分类表（category）中该商品所属分类的平均损耗率。
实现： 更新商品的损耗率，并返回所属的分类 ID；根据分类 ID，重新计算该分类的平均损耗率；更新分类表中的平均损耗率。
 
4.2.4 Postgres与DuckDB初步表现
对于上述十条语句，我们在同一实验环境下，对Postgres、DuckDB做了对比实验。实验结果如图。
图中，横轴（Query）： 代表不同的查询类型，包括 Q1-Q7（读取查询）和 I1、D1、U1（插入、删除和更新操作）。纵轴（Log of Execution time, ms）： 执行时间的对数值，反映查询的性能表现，数值越低表示性能越优。
从图表可以看出，读取查询（Q1-Q7）， DuckDB 的性能普遍优于 Postgres，尤其在 Q1、Q2 和 Q7 上表现明显。写操作（I1、D1、U1）： Postgres 的性能与 DuckDB 接近，但在插入（I1）操作中表现略优。 
4.2 关系型数据库的优化：索引
索引是一种数据结构，用于加速数据库表中数据的查询操作。它通过在指定字段上建立有序的数据结构（如B+树或哈希表），减少数据的扫描范围，从而提升查询效率。简单来说，索引类似于书的目录，通过目录可以快速定位到内容所在的页数，而无需逐页翻查。
在数据库中建立索引时，必须综合考虑多方面的因素。首先，查询频率和查询类型是决定是否建立索引的重要标准。如果某列频繁出现在 WHERE 子句、JOIN 连接条件或排序条件中，那么在该列上建立索引能够显著提高查询效率。其次，数据表的大小也很重要，对于大型表，索引能够显著减少扫描的数据量，从而提高查询性能；而对于小型表，索引带来的性能提升可能较为有限。再者，表的更新频率也需要考虑，如果表的插入、更新和删除操作频繁，索引会带来额外的维护成本，影响系统性能，因此，在更新频繁的表上应慎重添加索引。
另外，索引的选择性（即列中不同值的比例）也非常关键。对于高选择性的列（如唯一标识符），建立索引的效果非常显著，而低选择性的列（如性别、状态字段等）则不适合建立索引。此外，复合索引可以提高多列查询的效率，但需要合理选择索引的顺序和列数。查询执行计划分析也有助于评估索引的必要性，如果执行计划中显示全表扫描，可能表明需要为查询条件添加合适的索引。最后，索引类型的选择（如 B+树索引、哈希索引、全文索引等）应根据具体需求来决定，例如，B+树索引适合范围查询，哈希索引适合等值查询。
在本次项目中，根据字段使用频率与前面设计的SQL语句中where/join后面所连接的字段，并考虑到外键的使用，最终选择在sale表上的sale_date、sale_price、product_id、sale_quantity字段上建立索引，在wholesale表上的wholesale_date、wholesale_price、product_id字段上建立索引，在product表上的category_id上建立索引。
4.2 对比：Postgres与DuckDB
我们在简单和复杂查询上，分别对Postgres和DuckDB进行了性能测试。

 


 
4.2.2 实验结果分析
通过对运行结果的对比，我们有以下几点发现：
1.	PostgreSQL索引能显著加快简单查询速度
PostgreSQL with index在大多数查询中表现出较短的执行时间，尤其是在查询6和7中。这表明索引在PostgreSQL中对于提高查询性能非常关键。索引可以显著减少查询需要扫描的数据量，从而加快查询速度。
2.	DuckDB索引并不能带来明显的提升
在大多数查询中，DuckDB 是否建立索引对其性能的影响不大。这是因为DuckDB使用了列存结构，可以非常高效地扫描和处理数据，对许多查询，列式存储能代替传统索引的需求。也正因如此，DuckDB的优化器只会在比较少的情况中才使用索引。
3.	复杂查询的性能表现
虽然在Postgres上建立索引后，能带来很大的性能提升，但对于复杂查询，却不会有显著的提升，总体的执行时间都要大于DuckDB。这说明相较于以Postgres为代表的OLTP，以DuckDB为代表的OLAP更加适合在查询复杂的情况下进行分析
第五章	时序数据库的查询
5.1 简单查询
我们设计了8个简单查询，探究InfluxDB中查询标记为领域（field）属性的性能，并与关系型数据库进行比较。查询设计如表5-1所示：
表5-1 简单查询设计
度量名称	时间范围	领域属性名称
sale	全部	sale_price
wholesale	全部	wholesale_price
sale	2020.1.1-2022.1.1	sale_price
wholesale	2020.1.1-2022.1.1	wholesale_price
sale	2021.1.1-2022.1.1	sale_price
sale	2021.1.1-2022.1.1	sale_quantity
sale	2021.1.1-2022.1.1	discounted
wholesale	2021.1.1-2022.1.1	wholesale_price
对于上述每个查询，我们随机挑选1000个product_id，取平均查询时间作为结果。故上述查询设计转化为flux查询语言的规则为：

以第三个查询为例，其对应的flux查询语言为：
我们还将设计的简单查询转化为同义的SQL语言，在关系型数据库中进行相同语义的查询，以比较时许数据库与关系型数据库的性能。转换规则如下：
以第三个查询为例，其对应的SQL查询语言为：
5.2 复杂查询
考虑到时序数据库的特殊性，某些SQL的多表连接复杂查询无法在时序数据库找到同义对应，我们将SQL中的Q1，Q5改写为同义的flux语句，以比较

两者性能。改写后的语句如下：


第六章	关系型数据库与时序数据库的性能对比
6.1 简单查询
根据我们所设计的简单查询，我们在服务器上部署了DuckDB，Postgresql和InfluxDB三个数据库，并进行了相关性能测试，并且统计了各个数据库在不同查询中返回数据环节耗时的在总耗时中的比例。
6.1.1 实验结果
将表6-1的简单查询记录为Q1-Q8，实验结果如下：
 
图6-1 DuckDB、PostgreSQL和InfluxDB三种数据库执行Q1-Q8性能对比
 
图6-2 各个数据库返回数据环节耗时的在总耗时中的比例
6.1.2 实验分析
通过上述实验结果，我们发现了以下几点：
4.	InfluxDB性能表现不及预期
InfluxDB作为一种时序数据库，在大多数查询中执行时间最长，特别是在查询1、3和5中，InfluxDB的执行时间显著高于其他数据库。
5.	DuckDB性能整体较好
DuckDB with index在查询2和4中表现较好，但整体上不如PostgreSQL with index。
InfluxDB在简单查询中表现不佳，我们认为其主要原因是返回数据环节耗时过长。Q1和Q5的区别是时间范围不同，返回数据条目数量也不同。从图6-2中可以看出，InfluxDB的返回数据环节耗时在Q1，Q5中呈现出了相似的比例为44.9%和41.7%，，这代表返回数据的时间开销在InfluxDB中是无法忽略的。而在关系型数据库中，当数据量较少时，返回数据的时间几乎可以忽略（1.5%），这拉开了两者的性能差距。
6.2 复杂查询
根据我们所设计的复杂查询，我们相同环境下进行了相关性能测试。
6.2.1 实验结果
 
图6-3 各个数据库Q1，Q5查询语句执行时间
6.2.2 实验分析
在复杂查询中，查询主要涉及非时序数据或复杂的关联查询，因此关系型数据库可能表现更好在我们预期之内。这是因为因为关系型数据库在处理复杂查询和关联操作方面更加成熟和优化，并且查询需要进行复杂聚合或分析的操作，这些操作不是基于时间序列的。此外，两者的特性不同也在很大程度上影响了结果
具体来说，我们认为以下三个方面主要影响了两者的性能：
1.对于关系型数据库而言。可以同时查询多个属性；但对于时序数据库InfluxDB而言，一条查询结果中只包含一个领域属性，因此我们需要用pivot函数显式聚合所有属性，该操作耗时较长；
2.某些关系型数据库的函数不受InfluxDB支持，因此进行同义转换时需要用分多个步骤进行，进一步导致了耗时增加。例如InfluxDB不支持AVG关键字，因此我们需要使用reduce函数计算数据条目和数据总和，再用map函数计算平均结果；
3.返回结果时间长，同6.1.2。
第七章	实例展示
VegSalesDB是基于DuckDB的轻量级数据库操作系统，具备增删改查、高级筛选、分组、状态保存等核心功能，同时在性能优化和用户体验上表现出色。该Demo可以直观地展示我们对于蔬菜销售信息的功能设计和内容处理，它被直接部署到Github前端界面上，通过https://jeekzhang.github.io/VegSalesDB/可以访问体验。
7.1 功能详解
7.1.1 基础功能
系统通过动态数据加载与展示技术，使用DuckDB查询数据后，将其高效加载到表格中，并通过前端的AgGrid [9]展示。在AgGrid的支持下，表格不仅可以快速处理大规模数据，还提供了列自定义、分组以及多种筛选方式，极大提高了数据操作的灵活性。列操作是其中的亮点功能之一，用户可以自由隐藏或显示任意列，轻松调整表格视图。同时，通过点击Autosize按钮，表格列宽能够根据数据内容实现自适应调整，让表格展示更加整齐美观。此外，系统在表格底部增加了数据统计功能，不仅显示数据总行数，还能动态更新筛选后的行数，满足用户对数据的实时掌控需求。统计聚合功能进一步增强了数值字段的处理能力，用户可以直接对数据进行求和、平均值等计算。而在分页功能的支持下，系统采用后端服务模式进行分页加载，无需一次性加载全部数据，大大提升了大数据场景下的响应速度和处理性能。
7.1.2 增删改查（CRUD）
VegSalesDB提供了友好且高效的交互体验。新增记录功能通过Add按钮触发，弹出输入对话框，用户只需填写字段内容并提交，即可调用DuckDB的 INSERT 语句将新记录插入数据库。编辑记录功能通过表格中每行的Edit按钮实现，用户点击后可以修改指定记录的字段值，所有更改均通过对话框完成，最终通过DuckDB的UPDATE语句将修改同步至数据库。删除记录功能则采用 Delete 按钮来删除特定记录，并内置操作确认机制，避免误操作。删除操作直接通过DuckDB的DELETE语句实现，为用户提供了便捷且安全的数据删除途径。
7.1.3 数据筛选与分组
在高级筛选功能中，用户可以使用多个字段添加复杂条件，比如字符串匹配、数值范围过滤等，生成的动态SQL查询能够直接返回满足条件的结果，极大减少了数据筛选的复杂度。分组与展开功能同样强大，用户可以按任意字段对数据进行分组，支持多层嵌套分组操作。通过Expand和Collapse按钮，用户能快速展开或折叠分组视图，清晰呈现层级关系的同时，也为用户提供了简洁高效的数据浏览体验。
7.1.4 状态保存与加载
通过Save按钮，用户可以保存当前表格的状态，包括列显示、排序、分组和筛选条件，这些状态被序列化为JSON格式存储到数据库中。随后，用户可通过Load按钮快速恢复之前保存的视图设置，无需重复配置，大幅节省时间。这种状态管理功能不仅提高了操作效率，还让用户可以更专注于业务数据的分析与操作。
7.1.5 性能优化与体验
系统做了诸多努力以确保流畅的操作和快速的响应。DuckDB后端查询引擎能够高效处理大规模数据，通过Server-Side数据加载模式，只加载用户视角中需要的数据，从根本上解决了大数据量加载的性能瓶颈。页面交互也经过精心设计，例如延迟执行查询功能避免了用户界面卡顿问题，而合理的按钮布局和提示文本则提升了用户的操作直观性和友好性。
7.2 技术实现
受限于资源和可视化的需求，该系统实现了一个伪前后端部署的功能。对于每次执行的操作，仅在一张虚拟的数据表上进行。当页面刷新时，会重新从实体表读入数据，之前的数据操作会被清空。对于本次课程而言，我们完整地实现了下面介绍的功能，迁移到正式生产部署是可行的。
7.2.1 前端实现
VegSalesDB 的前端核心框架选用了React [10]，以其组件化开发模式实现高代码复用率和维护性。AgGrid作为表格的核心组件，不仅支持基础表格展示，还通过动态列定义（columnDefs）实现了字段排序、筛选、聚合等功能。每行操作按钮（Actions）通过自定义的cellRenderer添加了 Edit 和 Delete 按钮，这些按钮触发对应的事件，如弹出编辑对话框或删除记录，简化了用户操作逻辑。数据状态管理方面，React的useState和useEffect钩子用于管理表格数据、列定义以及对话框状态，确保了数据的一致性和交互的流畅性。CRUD操作通过Material UI的Dialog组件实现，用户只需填写或修改表单内容，即可完成对数据库的增删改查操作。
const defaultColDef = useMemo(() => {
  return {
    resizable: true,
    sortable: true,
    filter: true,
  };
}, []);
上述代码实现了字段排序、筛选、聚合、分组等功能，并为表格提供了强大的可视化能力
自定义列与行操作按钮的代码如下：
const actionsColumn = {
  field: 'actions',
  headerName: 'Actions',
  width: 120,
  filter: false,
  sortable: false,
  cellRenderer: (params: any) => (
    <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
      <IconButton size="small" onClick={() => handleEdit(params.data)}>
        <EditIcon fontSize="small" />
      </IconButton>
      <IconButton size="small" onClick={() => handleDelete(params.data.transactionId)}>
        <DeleteIcon fontSize="small" />
      </IconButton>
    </div>
  ),
};
React 的状态管理确保了数据的一致性和交互流畅性，例如：
const [openDialog, setOpenDialog] = useState(false);
const [dialogMode, setDialogMode] = useState<'create' | 'edit'>('create');
用户在对话框中输入数据，完成增删改查操作：
const DataOperationsDialog = ({ open, mode, onClose, onSubmit, initialData = {}, fields }) => {
  const [formData, setFormData] = useState(initialData);
  const handleSubmit = () => {
    onSubmit(formData);
    onClose();
  };
  return (
    <Dialog open={open} onClose={onClose}>
      <DialogTitle>{mode === 'create' ? 'Add New Record' : 'Edit Record'}</DialogTitle>
      <DialogContent>
        {fields.map(field => (
          <TextField
            key={field}
            label={field}
            value={formData[field] || ''}
            onChange={event => setFormData({ ...formData, [field]: event.target.value })}
            fullWidth
            margin="normal"
          />
        ))}
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>Cancel</Button>
        <Button onClick={handleSubmit} color="primary">
          {mode === 'create' ? 'Create' : 'Save'}
        </Button>
      </DialogActions>
    </Dialog>
  );
};
7.2.2 后端实现
DuckDB被用作内嵌式数据库引擎，具有强大的SQL查询能力，尤其在数据分析场景中表现优异。增删改查功能通过SQL语句实现，新增操作动态生成INSERT语句插入记录，编辑操作根据主键生成UPDATE语句更新记录，删除操作则通过DELETE语句完成，整个过程高效且简洁。同时，DuckDB的分页查询功能确保了大规模数据的快速加载和操作性能。
对数据库的增删改查的代码如下:
（1）查询操作
const query = `
SELECT column_name, data_type
FROM information_schema.columns
WHERE table_name = '${props.tableName}';
`;
（2）新增操作
async add(tableName, data) {
  const columns = Object.keys(data).join(", ");
  const values = Object.values(data).map(value => `'${value}'`).join(", ");
  const query = `INSERT INTO "${tableName}" (${columns}) VALUES (${values});`;
  await db.connect().query(query);
}
（3）编辑操作
async update(tableName, id, data) {
  const updates = Object.entries(data)
    .map(([key, value]) => `${key} = '${value}'`)
    .join(", ");
  const query = `UPDATE ${tableName} SET ${updates} WHERE transactionId = ${id};`;
  await db.connect().query(query);
}
（4）删除操作
async delete(tableName, id) {
  const query = `DELETE FROM ${tableName} WHERE transactionId = ${id};`;
  await db.connect().query(query);
}
7.2.3 功能扩展与优化
在高级筛选中，用户可以通过前端输入条件动态生成SQL查询语句，后端查询返回满足条件的记录，数据实时更新表格，提升筛选效率和准确性。状态保存与恢复则通过序列化为JSON格式存储表格配置，在加载时解析并恢复状态，为用户提供了极大的便利。
（1）动态SQL查询：
const fetchFilteredData = async (filterConditions) => {
  const query = `SELECT * FROM "${tableName}" WHERE ${filterConditions};`;
  const result = await db.connect().query(query);
  setGridData(result.toArray());
};
（2）状态序列化与存储：
const saveState = async (gridApi, tableName) => {
  const state = JSON.stringify(gridApi.getState());
  const query = `INSERT INTO "TableState" (tableName, state) VALUES ('${tableName}', '${state}');`;
  await db.connect().query(query);
};
const applySavedState = async (gridApi, tableName) => {
  const query = `SELECT state FROM "TableState" WHERE tableName = '${tableName}';`;
  const result = await db.connect().query(query);
  const savedState = JSON.parse(result.toArray()[0].state);
  gridApi.applyState(savedState);
};
7.2.4 用户界面与交互
我们充分考虑了自适应性和易用性，表格的宽度和高度能够根据窗口大小动态调整，确保在不同设备上的最佳显示效果。同时，系统支持深色和浅色主题切换，符合用户的个人偏好。快捷键支持功能更为常用操作提供了高效路径，如Ctrl+F打开搜索功能，进一步优化了用户体验。
（1）动态宽高调整
const gridStyle = useMemo(() => ({ height: "100%", width: "100%" }), []);
（2）动态切换表格样式
const prefersDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches;
const [darkMode, setDarkMode] = useState(prefersDarkMode);
（3）快捷键绑定
const handleKeyDown = (event, gridApi) => {
  if (event.ctrlKey && event.key === 'f') {
    openFilterBar(gridApi);
  }
};
7.3 界面展示
 
	受限于篇幅，我们下面将对增删改查这四个重点功能进行演示和介绍：
（1）当用户点击“ADD”按钮时，系统会进入添加新数据的流程，展示一个用于输入销售数据的表单界面。在此界面中，用户可以填写各个字段的信息。
 
当用户完成输入后，点击“CREATE”按钮即可完成数据的录入操作。随后，用户需要点击“RESET”按钮刷新页面以便查看最新的数据，此时新添加的内容会显示在数据表中。例如，下图中ID为0的记录即为新添加的内容。整个过程直观易用，并能确保用户快速添加所需数据。
 
（2）在删除操作中，当用户点击某行对应的垃圾桶图标时，系统会弹出一个提示框，内容为“Are you sure you want to delete the record with ID: X?”，其中X代表要删除记录的ID号，例如如果是删除ID为1的数据，则会显示相关提示。用户确认后，系统会标记该记录为删除状态，随后用户需要点击“RESET”按钮刷新页面，此时该记录将不再显示在数据表中。此流程提供了双重确认机制，确保用户不会因误操作而删除重要数据。
 
（3）对于修改操作，当用户点击某行的画笔图标时，系统会打开一个与添加操作类似的输入界面，用于修改现有的数据内容。用户可以在此界面中更新指定字段的信息，例如修改销售额或更正日期。完成修改后，点击“CREATE”按钮保存更改，然后点击“RESET”按钮刷新页面，此时修改后的内容会立即反映在数据表中。整个过程简单高效，用户可以快速定位并更新错误或需要调整的数据。
 
 
（4）在查询操作中，系统提供了灵活的筛选功能，用户可以通过界面顶部的搜索栏或右侧的条件筛选模块进行查询。用户可以输入关键字或选择特定的筛选条件，系统会立即显示符合条件的数据。此功能可帮助用户快速定位所需信息，提高数据检索的效率，并适应各种复杂的查询需求，使得数据管理更为高效便利。
第八章	总结和不足
在我们的性能对比测试中，我们评估了时序数据库和SQL数据库在处理时序数据方面的性能。出乎意料的是，结果显示时序数据库在多个测试场景中性能并不如SQL数据库。这一发现可能与多种因素有关，包括数据模型的复杂性、非时序数据处理能力、特定的性能优化等。
具体来说，尽管时序数据库专门为时序数据设计，优化了数据的写入、查询和分析，但SQL数据库可能展现出更好的性能和灵活性。
这些结果提示我们，在选择数据库时，不能简单地认为时序数据用时序数据库处理最为合适，也应综合考虑具体的应用场景、性能需求、数据模型以及现有的技术栈。对于主要处理时序数据且对性能有极高要求的应用，时序数据库可能仍然是更好的选择。但是，即使是面对时间范围的查询，关系型数据库的性能也相当优异。 
参考文献
[1]	Momjian B. PostgreSQL: introduction and concepts[J]. 2001.
[2]	Raasveldt M, Mühleisen H. Duckdb: an embeddable analytical database[C]//Proceedings of the 2019 International Conference on Management of Data. 2019: 1981-1984.
[3]	Naqvi S N Z, Yfantidou S, Zimányi E. Time series databases and influxdb[J]. Studienarbeit, Université Libre de Bruxelles, 2017, 12: 1-44. 
[4]	Date C J. A Guide to the SQL Standard[M]. Addison-Wesley Longman Publishing Co., Inc., 1989. 
[5]	Codd E F. Further normalization of the data base relational model[J]. Data base systems, 1972, 6: 33-64. 
[6]	Chen P P S. The entity-relationship model—toward a unified view of data[J]. ACM transactions on database systems (TODS), 1976, 1(1): 9-36. 
[7]	InfluxData. (n.d.). *Flux language documentation*. Retrieved from https://docs.influxdata.com/flux.
[8]	Transaction Processing Performance Council. (1992). *TPC-H: A Decision Support Benchmark* (Revision 2.0). Retrieved from https://www.tpc.org/tpch.
[9]	AG-Grid. (n.d.). *AG-Grid: The Best JavaScript Data Grid*. Retrieved from https://www.ag-grid.com.
[10]	Gackenheimer C. Introduction to React[M]. Apress, 2015.
